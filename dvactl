#!/usr/bin/env python
import argparse
import os
import json
import random
from deploy import compose, kube
try:
    import requests
except ImportError:
    print "Warning! requests module is required to use exec functionality."


def get_mode():
    if not os.path.isfile("mode.json"):
        return configure()
    return json.load(file("mode.json"))

def configure_kube():
    config = {}
    print "Creating configuration for kubernetes from kubeconfig.example.json"
    if os.path.isfile('kubeconfig.json'):
        config_template = json.load(file('kubeconfig.json'))
    else:
        config_template = json.load(file('kubeconfig.example.json'))
    for k,v in config_template.items():
        if "{random_string}" in v:
            v = v.format(random_string=random.randint(0,10000000))
        new_value = raw_input("Enter value for {} (Current value is '{}' press enter to keep current value) >>".format(k,v))
        if new_value.strip():
            config[k] = new_value
        else:
            config[k] = v
    with open('kubeconfig.json','w') as fout:
        json.dump(config,fout,indent=4)
    print "Save kubeconfig.json"


def configure(mode=None):
    gpu_count = 0
    if mode is None or not mode:
        mode = raw_input("Please select mode { dev, test, cpu, gpu, kube } >>").strip()
    if mode not in {'dev','test','cpu','gpu','kube'}:
        raise ValueError("{} is not a valid mode".format(mode))
    if mode == 'kube':
        configure_kube()
    if mode == 'gpu':
        gpu_count = int(raw_input("Please select number of GPUs >>").strip())
    with open("mode.json",'w') as f:
        mode_dict = {"mode":mode,'gpus':gpu_count}
        json.dump(mode_dict,f)
    return {"mode":mode,'gpus':gpu_count}


def exec_script(script_path):
    creds = json.load(file('creds.json'))
    server, token = creds['server'], creds['token']
    headers = {'Authorization': 'Token {}'.format(token)}
    r = requests.post("{server}queries/".format(server=server), data={'script': file(script_path).read()},
                      headers=headers)
    r.raise_for_status()
    if r.ok:
        print r.json()


if __name__ == '__main__':
    help_text = """
    Available options
    ./dvactl configure   
    ./dvactl create      
    ./dvactl start 
    ./dvactl auth  # recreates creds.json  
    ./dvactl exec --script_path script.json  # run process using creds.json and REST API
    ./dvactl stop 
    ./dvactl clean 
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("action",
                        help="Select action out of { configure | create | start | auth | exec | stop | clean "
                             "| clean_restart ")
    parser.add_argument("--init_process", help="Initial DVAPQL path default: configs/custom_defaults/init_process.json",
                        default="/root/DVA/configs/custom_defaults/init_process.json")
    parser.add_argument("--script_path", help="path to script to exec, e.g. process_livestream.json",
                        default="")
    parser.add_argument("--init_models", help="Path to trained_models.json:",
                        default="/root/DVA/configs/custom_defaults/trained_models.json")
    args = parser.parse_args()
    if args.action == 'configure':
        configure()
    elif args.action == 'exec':
        exec_script(args.script_path)
    else:
        mode_dict = get_mode()
        if mode_dict['mode'] == 'kube':
            kube.handle_kube_operations(args)
        else:
            if args.action == 'create':
                raise ValueError("create  is not required for compose, its used in kube mdoe to create GKE cluster")
            compose.handle_compose_operations(args,mode_dict['mode'],mode_dict['gpus'])